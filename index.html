<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body{
  margin:0;
  background:transparent;
  overflow:hidden;
  font-family: 'Segoe UI', sans-serif;
}

#contenedor{
  position:relative;
  margin:auto;
  top:40px;
  display: flex;
  justify-content: center;
  align-items: center;
}

#flecha{
  position:absolute;
  z-index:10;
  transform:translateX(-50%);
}

#flecha img{
  width:100%;
  height:100%;
  object-fit:contain;
  filter: drop-shadow(0 0 8px rgba(255,105,180,0.8));
}

#ruleta{
  border-radius:50%;
  border:12px solid white;
  box-shadow:0 0 40px rgba(255,105,180,.6);
  transition: transform 4.5s cubic-bezier(.17,.67,.83,.67);
}

#ganador{
  position:absolute;
  width:100%;
  text-align:center;
  font-size:32px;
  font-weight:bold;
  color:white;
  text-shadow:0 0 10px #ff69b4;
}
</style>
</head>
<body>

<div id="contenedor">
  <div id="flecha">
    <img src="corazon.png" alt="flecha">
  </div>
  <canvas id="ruleta"></canvas>
  <div id="ganador"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCxo_ndD5H5UM-q-qRA2jlikT8kXuvqEKA",
  authDomain: "obs-barra.firebaseapp.com",
  databaseURL: "https://obs-barra-default-rtdb.firebaseio.com",
  projectId: "obs-barra",
  storageBucket: "obs-barra.firebasestorage.app",
  messagingSenderId: "515697971120",
  appId: "1:515697971120:web:6cd07a5f10c46feef85075"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
const ganadorDiv = document.getElementById("ganador");
const flechaDiv = document.getElementById("flecha");
const contenedor = document.getElementById("contenedor");

let premiosActuales = [];
let ultimoResultado = null;

// Calcular tamaño óptimo de ruleta según cantidad de items
function calcularTamanoRuleta(cantidadPremios) {
  const baseSize = 500;
  if (cantidadPremios <= 8) return baseSize;
  if (cantidadPremios <= 12) return 600;
  if (cantidadPremios <= 16) return 700;
  if (cantidadPremios <= 20) return 800;
  return 900;
}

// Función para dividir texto largo en múltiples líneas
function dividirTexto(ctx, texto, maxWidth) {
  const palabras = texto.split(" ");
  const lineas = [];
  let lineaActual = palabras[0];

  for (let i = 1; i < palabras.length; i++) {
    const palabra = palabras[i];
    const ancho = ctx.measureText(lineaActual + " " + palabra).width;
    if (ancho < maxWidth) {
      lineaActual += " " + palabra;
    } else {
      lineas.push(lineaActual);
      lineaActual = palabra;
    }
  }
  lineas.push(lineaActual);
  return lineas;
}

function dibujarRuleta(premios){
  premiosActuales = premios;
  const total = premios.length;
  
  // Ajustar tamaño de canvas según cantidad de premios
  const tamano = calcularTamanoRuleta(total);
  canvas.width = tamano;
  canvas.height = tamano;
  
  const radio = tamano / 2;
  const angulo = (2 * Math.PI) / total;
  const colores = ["#ff99cc","#ff66b2"];
  
  // Ajustar tamaño de flecha
  const tamanoFlecha = tamano * 0.24; // 24% del tamaño de la ruleta
  flechaDiv.style.width = tamanoFlecha + "px";
  flechaDiv.style.height = tamanoFlecha + "px";
  flechaDiv.style.top = (-tamanoFlecha / 2) + "px";
  flechaDiv.style.left = "50%";
  
  // Ajustar posición del ganador
  ganadorDiv.style.bottom = (-70 * (tamano / 500)) + "px";
  
  // Ajustar tamaño de contenedor
  contenedor.style.width = tamano + "px";
  contenedor.style.height = tamano + "px";
  
  // Calcular tamaño de fuente dinámico
  let fontSize = 18;
  if (total > 8) fontSize = 16;
  if (total > 12) fontSize = 14;
  if (total > 16) fontSize = 12;
  if (total > 20) fontSize = 11;
  
  ctx.clearRect(0, 0, tamano, tamano);

  premios.forEach((texto, i) => {
    const start = i * angulo;
    const end = start + angulo;

    // Dibujar sector
    ctx.beginPath();
    ctx.moveTo(radio, radio);
    ctx.arc(radio, radio, radio, start, end);
    ctx.fillStyle = colores[i % 2];
    ctx.fill();

    // Dibujar texto
    ctx.save();
    ctx.translate(radio, radio);
    ctx.rotate(start + angulo / 2);
    ctx.textAlign = "right";
    ctx.fillStyle = "white";
    ctx.font = `bold ${fontSize}px Segoe UI`;
    
    // Calcular ancho máximo para el texto en este sector
    const maxAnchoTexto = radio * 0.7;
    const lineas = dividirTexto(ctx, texto, maxAnchoTexto);
    
    // Dibujar cada línea de texto
    const alturaLinea = fontSize * 1.2;
    const offsetY = -(lineas.length - 1) * alturaLinea / 2;
    
    lineas.forEach((linea, index) => {
      const y = offsetY + (index * alturaLinea);
      ctx.fillText(linea, radio * 0.88, y);
    });
    
    ctx.restore();
  });
}

onValue(ref(db,"ruleta"), snap=>{
  const data = snap.val();
  if(!data) return;

  dibujarRuleta(data.premios);

  // Verificar si es una actualización real
  if(ultimoResultado !== null && ultimoResultado !== data.resultado){
    canvas.style.transition = "none";
    canvas.style.transform = "rotate(0deg)";
    ganadorDiv.textContent = "";

    void canvas.offsetHeight;

    canvas.style.transition = "transform 4.5s cubic-bezier(.17,.67,.83,.67)";
  }

  const index = data.premios.indexOf(data.resultado);
  const angulo = 360 / data.premios.length;
  const anguloSectorGanador = (index * angulo) + (angulo / 2);
  const giroFinal = (360 * 6) + (270 - anguloSectorGanador);

  setTimeout(()=>{
    canvas.style.transform = `rotate(${giroFinal}deg)`;
  }, ultimoResultado !== null ? 50 : 0);

  ultimoResultado = data.resultado;

  setTimeout(()=>{
    ganadorDiv.textContent = "✨ " + data.resultado + " ✨";
  }, 8500);
});
</script>

</body>
</html>
