<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body{
  margin:0;
  background:transparent;
  overflow:hidden;
  font-family: 'Segoe UI', sans-serif;
  width: 100vw;           /* ← NUEVO */
  height: 100vh;          /* ← NUEVO */
  position: relative;     /* ← NUEVO */
}

#contenedor{
  position:absolute;      /* ← CAMBIÓ de relative */
  left:50%;              /* ← NUEVO */
  top:50%;               /* ← CAMBIÓ */
  transform:translate(-50%, -50%);  /* ← NUEVO */
  display: flex;
  justify-content: center;
  align-items: center;
}

#flecha{
  position:absolute;
  z-index:10;
  transform:translateX(-50%);
}

#flecha img{
  width:100%;
  height:100%;
  object-fit:contain;
  filter: drop-shadow(0 0 8px rgba(255,105,180,0.8));
}

#ruleta{
  border-radius:50%;
  border:12px solid white;
  box-shadow:0 0 40px rgba(255,105,180,.6);
  transition: transform 4.5s cubic-bezier(.17,.67,.83,.67);
}

#ganador{
  position:fixed;         /* ← CAMBIÓ a fixed */
  z-index:9999;  
  width:80%;
  text-align:center;
  font-size:48px;
  font-weight:bold;
  color:white;
  text-shadow:
    0 0 20px #ff69b4,
    0 0 40px #ff1493,
    2px 2px 4px rgba(0,0,0,0.8);
  background:rgba(255,20,147,0.9);
  padding:30px 40px;
  border-radius:20px;
  border:4px solid white;
  box-shadow:0 0 60px rgba(255,105,180,0.9);
  opacity:0;
  transform:scale(0.5);
  transition:all 0.5s ease-out;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%) scale(0.5);  /* ← Un solo transform */
  transition:all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  pointer-events: none;   /* ← NUEVO */
}

#ganador.mostrar{
  opacity:1;
  transform:translate(-50%, -50%) scale(1);
}
</style>
</head>
<body>


<div id="contenedor">
  <div id="flecha">
    <img src="corazon.png" alt="flecha">
  </div>
  <canvas id="ruleta"></canvas>
</div>

<div id="ganador"></div> 

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCxo_ndD5H5UM-q-qRA2jlikT8kXuvqEKA",
  authDomain: "obs-barra.firebaseapp.com",
  databaseURL: "https://obs-barra-default-rtdb.firebaseio.com",
  projectId: "obs-barra",
  storageBucket: "obs-barra.firebasestorage.app",
  messagingSenderId: "515697971120",
  appId: "1:515697971120:web:6cd07a5f10c46feef85075"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
const ganadorDiv = document.getElementById("ganador");
const flechaDiv = document.getElementById("flecha");
const contenedor = document.getElementById("contenedor");

let premiosActuales = [];
let ultimoResultado = null;
let audioContext = null;
let intervaloSonido = null;

// Inicializar AudioContext
function inicializarAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
}

// Función para generar sonido de "tick"
function reproducirTick() {
  if (!audioContext) inicializarAudio();
  
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  // Configurar el sonido
  oscillator.type = 'sine';
  oscillator.frequency.value = 800; // Frecuencia del tick
  
  // Configurar el volumen
  gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
  
  // Reproducir
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.05);
}

// Calcular tamaño óptimo de ruleta según cantidad de items
function calcularTamanoRuleta(cantidadPremios) {
  const baseSize = 500;
  if (cantidadPremios <= 8) return baseSize;
  if (cantidadPremios <= 12) return 600;
  if (cantidadPremios <= 16) return 700;
  if (cantidadPremios <= 20) return 800;
  return 900;
}

// Función para dividir texto largo en múltiples líneas
function dividirTexto(ctx, texto, maxWidth) {
  const palabras = texto.split(" ");
  const lineas = [];
  let lineaActual = palabras[0];

  for (let i = 1; i < palabras.length; i++) {
    const palabra = palabras[i];
    const ancho = ctx.measureText(lineaActual + " " + palabra).width;
    if (ancho < maxWidth) {
      lineaActual += " " + palabra;
    } else {
      lineas.push(lineaActual);
      lineaActual = palabra;
    }
  }
  lineas.push(lineaActual);
  return lineas;
}

function dibujarRuleta(premios){
  premiosActuales = premios;
  const total = premios.length;
  
  // Ajustar tamaño de canvas según cantidad de premios
  const tamano = calcularTamanoRuleta(total);
  canvas.width = tamano;
  canvas.height = tamano;
  
  const radio = tamano / 2;
  const angulo = (2 * Math.PI) / total;
  const colores = ["#ff99cc","#ff66b2"];
  
  // Ajustar tamaño de flecha
  const tamanoFlecha = tamano * 0.24; // 24% del tamaño de la ruleta
  flechaDiv.style.width = tamanoFlecha + "px";
  flechaDiv.style.height = tamanoFlecha + "px";
  flechaDiv.style.top = (-tamanoFlecha / 2) + "px";
  flechaDiv.style.left = "50%";
  
  // Ajustar tamaño de contenedor
  contenedor.style.width = tamano + "px";
  contenedor.style.height = tamano + "px";
  
  // Calcular tamaño de fuente dinámico
  let fontSize = 18;
  if (total > 8) fontSize = 16;
  if (total > 12) fontSize = 14;
  if (total > 16) fontSize = 12;
  if (total > 20) fontSize = 11;
  
  ctx.clearRect(0, 0, tamano, tamano);

  premios.forEach((texto, i) => {
    const start = i * angulo;
    const end = start + angulo;

    // Dibujar sector
    ctx.beginPath();
    ctx.moveTo(radio, radio);
    ctx.arc(radio, radio, radio, start, end);
    ctx.fillStyle = colores[i % 2];
    ctx.fill();

    // Dibujar texto
    ctx.save();
    ctx.translate(radio, radio);
    ctx.rotate(start + angulo / 2);
    ctx.textAlign = "right";
    ctx.fillStyle = "white";
    ctx.font = `bold ${fontSize}px Segoe UI`;
    
    // Calcular ancho máximo para el texto en este sector
    const maxAnchoTexto = radio * 0.7;
    const lineas = dividirTexto(ctx, texto, maxAnchoTexto);
    
    // Dibujar cada línea de texto
    const alturaLinea = fontSize * 1.2;
    const offsetY = -(lineas.length - 1) * alturaLinea / 2;
    
    lineas.forEach((linea, index) => {
      const y = offsetY + (index * alturaLinea);
      ctx.fillText(linea, radio * 0.88, y);
    });
    
    ctx.restore();
  });
}

// Función para reproducir ticks durante el giro
function iniciarTicks(duracionMs) {
  // Limpiar intervalo anterior si existe
  if (intervaloSonido) {
    clearInterval(intervaloSonido);
  }
  
  inicializarAudio();
  
  // Empezar con ticks lentos y acelerar
  let intervalo = 200; // Milisegundos entre ticks
  const tiempoInicio = Date.now();
  
  function programarTick() {
    const tiempoTranscurrido = Date.now() - tiempoInicio;
    const progreso = tiempoTranscurrido / duracionMs;
    
    if (progreso >= 1) {
      // Terminar
      if (intervaloSonido) clearTimeout(intervaloSonido);
      return;
    }
    
    reproducirTick();
    
    // Calcular próximo intervalo (más rápido al principio, más lento al final)
    intervalo = 50 + (150 * (1 - progreso));
    
    intervaloSonido = setTimeout(programarTick, intervalo);
  }
  
  programarTick();
}

onValue(ref(db,"ruleta"), snap=>{
  const data = snap.val();
  if(!data) return;

  dibujarRuleta(data.premios);

  // Verificar si es una actualización real
  if(ultimoResultado !== null && ultimoResultado !== data.resultado){
    canvas.style.transition = "none";
    canvas.style.transform = "rotate(0deg)";
    ganadorDiv.textContent = "";
    ganadorDiv.classList.remove("mostrar");

    void canvas.offsetHeight;

    canvas.style.transition = "transform 4.5s cubic-bezier(.17,.67,.83,.67)";
    
    // Iniciar sonidos de tick
    iniciarTicks(4500);
  }

  const index = data.premios.indexOf(data.resultado);
  const angulo = 360 / data.premios.length;
  const anguloSectorGanador = (index * angulo) + (angulo / 2);
  const giroFinal = (360 * 6) + (270 - anguloSectorGanador);

  setTimeout(()=>{
    canvas.style.transform = `rotate(${giroFinal}deg)`;
  }, ultimoResultado !== null ? 50 : 0);

  ultimoResultado = data.resultado;

  // Mostrar ganador en el centro después de que termine el giro
  setTimeout(()=>{
    ganadorDiv.textContent = "✨ " + data.resultado + " ✨";
    ganadorDiv.classList.add("mostrar");
  }, 7300);
});
</script>

</body>
</html>