<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body{
  margin:0;
  background:transparent;
  overflow:hidden;
  font-family: 'Segoe UI', sans-serif;
  width: 100vw;
  height: 100vh;
  position: relative;
}

#contenedor{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%, -50%);
  display: flex;
  justify-content: center;
  align-items: center;
}

#flecha{
  position:absolute;
  z-index:10;
  transform:translateX(-50%);
}

#flecha img{
  width:100%;
  height:100%;
  object-fit:contain;
  filter: drop-shadow(0 0 8px rgba(255,105,180,0.8));
}

#ruleta{
  border-radius:50%;
  border:12px solid white;
  box-shadow:0 0 40px rgba(255,105,180,.6);
  transition: transform 4.5s cubic-bezier(.17,.67,.83,.67);
}

#ganador{
  position:fixed;
  z-index:9999;
  width:80%;
  max-width:700px;
  text-align:center;
  font-size:42px;
  font-weight:900;
  color:#ffffff;
  text-shadow:
    0 0 20px #ff69b4,
    0 0 40px #ff1493,
    0 0 60px #ff69b4,
    3px 3px 8px rgba(0,0,0,1),
    -2px -2px 8px rgba(0,0,0,1);
  background:linear-gradient(135deg, #ff1493 0%, #ff69b4 100%);
  padding:35px 45px;
  border-radius:25px;
  border:6px solid #ffffff;
  box-shadow:
    0 0 80px rgba(255,20,147,1),
    0 10px 40px rgba(0,0,0,0.8),
    inset 0 0 30px rgba(255,255,255,0.3);
  opacity:0;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%) scale(0.5);
  transition:all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  letter-spacing:2px;
  pointer-events: none;
}

#ganador.mostrar{
  opacity:1;
  transform:translate(-50%, -50%) scale(1);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    box-shadow:
      0 0 80px rgba(255,20,147,1),
      0 10px 40px rgba(0,0,0,0.8),
      inset 0 0 30px rgba(255,255,255,0.3);
  }
  50% {
    box-shadow:
      0 0 120px rgba(255,20,147,1),
      0 10px 50px rgba(0,0,0,0.9),
      inset 0 0 40px rgba(255,255,255,0.4);
  }
}
</style>
</head>
<body>

<div id="contenedor">
  <div id="flecha">
    <img src="corazon.png" alt="flecha">
  </div>
  <canvas id="ruleta"></canvas>
</div>

<div id="ganador"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCxo_ndD5H5UM-q-qRA2jlikT8kXuvqEKA",
  authDomain: "obs-barra.firebaseapp.com",
  databaseURL: "https://obs-barra-default-rtdb.firebaseio.com",
  projectId: "obs-barra",
  storageBucket: "obs-barra.firebasestorage.app",
  messagingSenderId: "515697971120",
  appId: "1:515697971120:web:6cd07a5f10c46feef85075"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
const ganadorDiv = document.getElementById("ganador");
const flechaDiv = document.getElementById("flecha");
const contenedor = document.getElementById("contenedor");

let premiosActuales = [];
let ultimoResultado = null;
let audioContext = null;
let timeoutsSonido = [];

// Inicializar AudioContext
function inicializarAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Reanudar el contexto si está suspendido
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

// Función para generar sonido de "tick"
function reproducirTick() {
  try {
    if (!audioContext) inicializarAudio();
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Configurar el sonido
    oscillator.type = 'sine';
    oscillator.frequency.value = 800; // Frecuencia del tick
    
    // Configurar el volumen
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
    
    // Reproducir
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.05);
  } catch(e) {
    console.log("Error al reproducir tick:", e);
  }
}

// Calcular tamaño óptimo de ruleta según cantidad de items
function calcularTamanoRuleta(cantidadPremios) {
  const baseSize = 500;
  if (cantidadPremios <= 8) return baseSize;
  if (cantidadPremios <= 12) return 600;
  if (cantidadPremios <= 16) return 700;
  if (cantidadPremios <= 20) return 800;
  return 900;
}

// Función para dividir texto largo en múltiples líneas
function dividirTexto(ctx, texto, maxWidth) {
  const palabras = texto.split(" ");
  const lineas = [];
  let lineaActual = palabras[0];

  for (let i = 1; i < palabras.length; i++) {
    const palabra = palabras[i];
    const ancho = ctx.measureText(lineaActual + " " + palabra).width;
    if (ancho < maxWidth) {
      lineaActual += " " + palabra;
    } else {
      lineas.push(lineaActual);
      lineaActual = palabra;
    }
  }
  lineas.push(lineaActual);
  return lineas;
}

function dibujarRuleta(premios){
  premiosActuales = premios;
  const total = premios.length;
  
  // Ajustar tamaño de canvas según cantidad de premios
  const tamano = calcularTamanoRuleta(total);
  canvas.width = tamano;
  canvas.height = tamano;
  
  const radio = tamano / 2;
  const angulo = (2 * Math.PI) / total;
  const colores = ["#ff99cc","#ff66b2"];
  
  // Ajustar tamaño de flecha
  const tamanoFlecha = tamano * 0.24; // 24% del tamaño de la ruleta
  flechaDiv.style.width = tamanoFlecha + "px";
  flechaDiv.style.height = tamanoFlecha + "px";
  flechaDiv.style.top = (-tamanoFlecha / 2) + "px";
  flechaDiv.style.left = "50%";
  
  // Ajustar tamaño de contenedor
  contenedor.style.width = tamano + "px";
  contenedor.style.height = tamano + "px";
  
  // Calcular tamaño de fuente dinámico
  let fontSize = 18;
  if (total > 8) fontSize = 16;
  if (total > 12) fontSize = 14;
  if (total > 16) fontSize = 12;
  if (total > 20) fontSize = 11;
  
  ctx.clearRect(0, 0, tamano, tamano);

  premios.forEach((texto, i) => {
    const start = i * angulo;
    const end = start + angulo;

    // Dibujar sector
    ctx.beginPath();
    ctx.moveTo(radio, radio);
    ctx.arc(radio, radio, radio, start, end);
    ctx.fillStyle = colores[i % 2];
    ctx.fill();

    // Dibujar texto
    ctx.save();
    ctx.translate(radio, radio);
    ctx.rotate(start + angulo / 2);
    ctx.textAlign = "right";
    ctx.fillStyle = "white";
    ctx.font = `bold ${fontSize}px Segoe UI`;
    
    // Calcular ancho máximo para el texto en este sector
    const maxAnchoTexto = radio * 0.7;
    const lineas = dividirTexto(ctx, texto, maxAnchoTexto);
    
    // Dibujar cada línea de texto
    const alturaLinea = fontSize * 1.2;
    const offsetY = -(lineas.length - 1) * alturaLinea / 2;
    
    lineas.forEach((linea, index) => {
      const y = offsetY + (index * alturaLinea);
      ctx.fillText(linea, radio * 0.88, y);
    });
    
    ctx.restore();
  });
}

// Función para reproducir ticks durante el giro
function iniciarTicks(duracionMs) {
  // Limpiar timeouts anteriores
  timeoutsSonido.forEach(timeout => clearTimeout(timeout));
  timeoutsSonido = [];
  
  inicializarAudio();
  
  // Empezar con ticks lentos y acelerar
  let intervalo = 200; // Milisegundos entre ticks
  const tiempoInicio = Date.now();
  
  function programarTick() {
    const tiempoTranscurrido = Date.now() - tiempoInicio;
    const progreso = tiempoTranscurrido / duracionMs;
    
    if (progreso >= 1) {
      // Terminar
      return;
    }
    
    reproducirTick();
    
    // Calcular próximo intervalo (más rápido al principio, más lento al final)
    intervalo = 50 + (150 * (1 - progreso));
    
    const timeout = setTimeout(programarTick, intervalo);
    timeoutsSonido.push(timeout);
  }
  
  programarTick();
}

onValue(ref(db,"ruleta"), snap=>{
  const data = snap.val();
  if(!data) return;

  dibujarRuleta(data.premios);

  // Solo girar si hay un cambio real de resultado (no al cargar la página)
  if(ultimoResultado !== null && ultimoResultado !== data.resultado){
    canvas.style.transition = "none";
    canvas.style.transform = "rotate(0deg)";
    ganadorDiv.textContent = "";
    ganadorDiv.classList.remove("mostrar");

    void canvas.offsetHeight;

    canvas.style.transition = "transform 4.5s cubic-bezier(.17,.67,.83,.67)";
    
    // Iniciar sonidos de tick
    iniciarTicks(4500);

    const index = data.premios.indexOf(data.resultado);
    const angulo = 360 / data.premios.length;
    const anguloSectorGanador = (index * angulo) + (angulo / 2);
    const giroFinal = (360 * 6) + (270 - anguloSectorGanador);

    setTimeout(()=>{
      canvas.style.transform = `rotate(${giroFinal}deg)`;
    }, 50);

    // Mostrar ganador en el centro después de que termine el giro
    setTimeout(()=>{
      ganadorDiv.textContent = "✨ " + data.resultado + " ✨";
      ganadorDiv.classList.add("mostrar");
    }, 4600);
  }

  ultimoResultado = data.resultado;
});

// Inicializar audio context con el primer click/interacción
document.addEventListener('click', inicializarAudio, { once: true });
document.addEventListener('keydown', inicializarAudio, { once: true });
</script>

</body>
</html>